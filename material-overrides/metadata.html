{% extends "main.html" %}
{% block content %}

<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Metadata Explorer</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/javascript">
        // React component (converted to standard JS)

        const { useState, useEffect } = React;

        // Mocking @polkadot/api and package.json for standalone HTML
        const ApiPromise = {
            create: async function ({ provider }) {
                // Simulate API connection and metadata retrieval
                return new Promise((resolve) => {
                    setTimeout(() => {
                        resolve({
                            rpc: {
                                state: {
                                    getMetadata: () => {
                                        return new Promise(resolve => {
                                            setTimeout(() => resolve({
                                                toHuman: () => ({
                                                    metadata: {
                                                        V14: { // Replace V14 with your target version
                                                            lookup: { types: [] },
                                                            pallets: [
                                                                { name: "System", constants: [], errors: [], events: [], extrinsics: [], storage: [] }, //minimal
                                                                { name: "Balances", constants: [], errors: [], events: [], extrinsics: [], storage: [] }, //minimal
                                                            ],
                                                        }
                                                    }
                                                })
                                            }), 250); //simulate network
                                        })
                                    }
                                }
                            },
                            consts: { system: {}, balances: {} }, // Minimal mock
                            errors: { system: {}, balances: {} }, // Minimal mock
                            events: { system: {}, balances: {} }, // Minimal mock
                            tx: { system: {}, balances: {} },     // Minimal mock
                            query: { system: {}, balances: {} },    // Minimal mock
                            call: { system: {}, balances: {} }       //Minimal
                        });
                    }, 250); // Simulate network delay for API creation.
                });
            }
        };

        const WsProvider = function (wsUrl) {
            this.wsUrl = wsUrl;  // Store URL.  Not actually connecting.
        };



        const Packages = {
            devDependencies: {
                "@polkadot/api": "^10.9.1" // Replace with the desired version
            }
        };

        const PolkadotJSVersion = Packages.devDependencies["@polkadot/api"].substring(1);

        const Networks = [
            { name: "Polkadot", rpc: "wss://rpc.ibp.network/polkadot" },
            { name: "Polkadot Asset Hub", rpc: "wss://polkadot-asset-hub-rpc.polkadot.io" },
            { name: "Polkadot People", rpc: "wss://polkadot-people-rpc.polkadot.io" },
            { name: "Polkadot Bridge Hub", rpc: "wss://polkadot-bridge-hub-rpc.polkadot.io" },
            { name: "Polkadot Collectives", rpc: "wss://polkadot-collectives-rpc.polkadot.io" },
            { name: "Polkadot Coretime", rpc: "wss://polkadot-coretime-rpc.polkadot.io" },
            { name: "Kusama", rpc: "wss://rpc.ibp.network/kusama" },
            { name: "Kusama Asset Hub", rpc: "wss://kusama-asset-hub-rpc.polkadot.io" },
            { name: "Kusama People", rpc: "wss://kusama-people-rpc.polkadot.io" },
            { name: "Kusama Bridge Hub", rpc: "wss://kusama-bridge-hub-rpc.polkadot.io" },
            { name: "Kusama Coretime", rpc: "wss://kusama-coretime-rpc.polkadot.io" },
            { name: "Westend", rpc: "wss://westend-rpc.polkadot.io" },
        ];

        const CommonRuntimeModules = ["auctions", "claims", "crowdloan", "registrar", "slots"];
        const CommonParachainRuntimeModules = ["configuration", "hrmp", "initializer", "paras_inherent", "paras", "disputes", "disputes/slashing"];
        const PalletNameMappings = {
            "registrar": "paras_registrar",
            "xcmpallet": "xcm",
            "voterlist": "bags_list",
            "fastunstake": "fast_unstake",
            "childbounties": "child_bounties",
            "nominationpools": "nomination_pools",
            "convictionvoting": "conviction_voting",
            "imonline": "im_online",
            "parasdisputes": "disputes",
            "parasslashing": "disputes/slashing",
            "parainherent": "paras_inherent",
            "messagequeue": "message_queue",
            "electionprovidermultiphase": "election_provider_multi_phase",
            "system": "frame_system",
        };


        let Expandable = [];
        let SearchThrottle;

        function Metadata({ version }) {
            const [returnValue, setReturnValue] = useState("");

            useEffect(() => {
                const fetchMetadata = async () => {
                    let defaultNetwork = "Polkadot";
                    if (document.title === "Metadata Explorer · Guide") {
                        defaultNetwork = "Kusama";
                    }

                    const network = Networks.find((network) => network.name === defaultNetwork);
                    const wsUrl = network.rpc;

                    let options = [];
                    Networks.forEach((chain) => {
                        const option = (
                            React.createElement('option', { value: chain.rpc, key: chain.name },
                                `${chain.name.charAt(0).toUpperCase() + chain.name.slice(1)}`
                            )
                        );
                        options.push(option);
                    });

                    const dropdown = (
                        React.createElement('select', {
                            defaultValue: network.rpc,
                            style: DropDownStyle,
                            onChange: (e) =>
                                GetMetadata(version, e.target.value, dropdown, setReturnValue)
                        },
                            options
                        )
                    );

                    setReturnValue(
                        React.createElement('div', { style: PinkText },
                            React.createElement('b', null, 'Loading Metadata Explorer...')
                        )
                    );

                    await GetMetadata(version, wsUrl, dropdown, setReturnValue);
                };

                fetchMetadata();
            }, [version]);

            return returnValue;
        }

        async function GetMetadata(version, wsUrl, dropdown, setReturnValue) {
            ToggleLoading("metadataLoading", false);
            const wsProvider = new WsProvider(wsUrl);
            const api = await ApiPromise.create({ provider: wsProvider });
            Expandable = [];

            const rawMeta = await api.rpc.state.getMetadata();
            const meta = rawMeta.toHuman();

            const types = meta.metadata[version].lookup.types;
            const pallets = meta.metadata[version].pallets;
            pallets.sort((a, b) => a.name.localeCompare(b.name));

            let palletData = [];

            pallets.forEach(pallet => {

                const constants = BuildPalletItems(pallet, api.consts[`${Camel(pallet.name)}`], "constants", types);
                const errors = BuildPalletItems(pallet, api.errors[`${Camel(pallet.name)}`], "errors", types);
                const events = BuildPalletItems(pallet, api.events[`${Camel(pallet.name)}`], "events", types);
                const extrinsics = BuildPalletItems(pallet, api.tx[`${Camel(pallet.name)}`], "extrinsics", types);
                const storage = BuildPalletItems(pallet, api.query[Camel(pallet.name)], "storage", types);

                const constantElements = CompilePalletSection(pallet.name, "constants", constants);
                const errorElements = CompilePalletSection(pallet.name, "errors", errors);
                const eventElements = CompilePalletSection(pallet.name, "events", events);
                const extrinsicElements = CompilePalletSection(pallet.name, "extrinsics", extrinsics);
                const storageElements = CompilePalletSection(pallet.name, "storage", storage);

                palletData.push(
                    React.createElement('div', { key: pallet.name, style: SecondLevel },
                        React.createElement('span', null,
                            React.createElement('b', { id: `${pallet.name}-button`, style: TreeControl, onClick: () => { ToggleExpand(pallet.name) } }, "+"),
                            " ",
                            React.createElement('b', null, pallet.name)
                        ),
                        React.createElement('div', { id: pallet.name, style: TopLevelDiv },
                            constantElements,
                            errorElements,
                            eventElements,
                            extrinsicElements,
                            storageElements
                        )
                    )
                );

                Expandable.push(pallet.name);
                Expandable.push(`${pallet.name}-constants`, `${pallet.name}-errors`, `${pallet.name}-events`, `${pallet.name}-extrinsics`, `${pallet.name}-storage`);
            });

            const rpcs = BuildRPCOrRuntime(api.rpc, "rpc");
            const runtime = BuildRPCOrRuntime(api.call, "runtime");


            ToggleLoading("metadataLoading", true);

            setReturnValue(
                React.createElement('div', null,
                    React.createElement('div', { style: ExplorerControls },
                        React.createElement('input', { id: "metaSearch", type: "text", placeholder: "Search Metadata", style: SearchStyle, onInput: () => Search() }),
                        React.createElement('br', null),
                        dropdown,
                        React.createElement('div', { id: "buttonControls" },
                            React.createElement('button', { style: ExpandCollapseButton, onClick: () => ExpandAll(true) }, React.createElement('span', { style: { fontSize: "10px" } }, "Expand All")),
                            React.createElement('button', { style: ExpandCollapseButton, onClick: () => ExpandAll(false) }, React.createElement('span', { style: { fontSize: "10px" } }, "Collapse All"))
                        ),
                        React.createElement('div', { style: { fontSize: "10px" } },
                            React.createElement('b', { style: PinkText }, "metadata"),
                            React.createElement('b', null, ` ${version}`),
                            " ",
                            React.createElement('b', { style: PinkText }, "@polkadot/api"),
                            React.createElement('b', null, ` V${PolkadotJSVersion}`)
                        ),
                        React.createElement('div', { id: "metadataLoading", style: LoadingStatus }, React.createElement('b', null, `Connecting to ${wsUrl}...`)),
                        React.createElement('div', { id: "searchLoading", style: LoadingStatus }, React.createElement('b', null, "Searching...")),
                        React.createElement('div', { id: "searchResults", style: LoadingStatus }, React.createElement('b', null, 'Matches: '), React.createElement('b', { id: "searchCount", style: PinkText }, "0"))
                    ),
                    React.createElement('b', { style: TopLevel }, "Pallets:"),
                    palletData,
                    React.createElement('br', null),
                    React.createElement('b', { style: TopLevel }, "RPC:"),
                    rpcs,
                    React.createElement('br', null),
                    React.createElement('b', { style: TopLevel }, "Runtime:"),
                    runtime
                )
            );
        }


        function BuildPalletItems(pallet, call, type, types) {
            let output = [];
            if (call !== undefined && call !== null) {
                const keys = Object.keys(call).sort((a, b) => a.localeCompare(b));
                keys.forEach(key => {
                    const meta = call[key] ? call[key].meta.toHuman() : { docs: [] };  //handle potentially missing
                    const description = FormatDescription(pallet.name.toLowerCase(), meta.docs.join(" "));
                    const keyUpper = key.charAt(0).toUpperCase() + key.slice(1);
                    let list;
                    switch (type) {
                        case "constants":
                            const constType = types[meta.type]?.type.def || {}; //handle potentially missing type info
                            const constTypeKey = Object.keys(constType)[0] || "";
                            const constTypeValue = Object.values(constType)[0] || "";

                            list = (
                                React.createElement('ul', null,
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Description"), ": ", description),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "API Endpoint"), ": ", React.createElement('span', { style: PinkText }, `api.consts.<span class="math-inline">\{Camel\(pallet\.name\)\}\.</span>{Camel(key)}`)),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Chain Value"), ": ", React.createElement('span', { style: PinkText }, `${JSON.stringify(call[key])}`)),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Chain Value Type"), ": ", `(${constTypeKey}: ${constTypeValue})`)
                                )
                            );
                            break;
                        case "errors":
                            list = (
                                React.createElement('ul', null,
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Description"), ": ", description),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "API Endpoint"), ": ", React.createElement('span', { style: PinkText }, `api.errors.<span class="math-inline">\{Camel\(pallet\.name\)\}\.</span>{Camel(key)}`))
                                )
                            );
                            break;
                        case "events":
                            list = (
                                React.createElement('ul', null,
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Description"), ": ", description),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "API Endpoint"), ": ", React.createElement('span', { style: PinkText }, `api.events.<span class="math-inline">\{Camel\(pallet\.name\)\}\.</span>{Camel(key)}`)),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Fields"), ": ", FormatArgs(meta, "events"))
                                )
                            );
                            break;
                        case "extrinsics":
                            list = (
                                React.createElement('ul', null,
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Description"), ": ", description),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "API Endpoint"), ": ", React.createElement('span', { style: PinkText }, `api.tx.<span class="math-inline">\{Camel\(pallet\.name\)\}\.</span>{Camel(key)}`)),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Parameters"), ": ", FormatArgs(meta, "extrinsics"))
                                )
                            );
                            break;
                        case "storage":
                            list = (
                                React.createElement('ul', null,
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Description"), ": ", description),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "API Endpoint"), ": ", React.createElement('span', { style: PinkText }, `api.query.<span class="math-inline">\{Camel\(pallet\.name\)\}\.</span>{Camel(key)}`)),
                                    React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Return Type"), ": ", FormatArgs(meta, "storage", types))
                                )
                            );
                            break;
                        default:
                            item = undefined;
                            break;
                    }
                    const item = (
                        React.createElement('li', { key: key },
                            React.createElement('b', null, keyUpper),
                            list
                        )
                    );
                    output.push(item);
                });
            }
            output = IsEmpty(output);
            return output;
        }

        function BuildRPCOrRuntime(call, type) {
            let output = [];
            const keys = Object.keys(call);
            keys.sort((a, b) => a.localeCompare(b));

            keys.forEach(key => {
                let children = [];
                const methods = call[key];
                if (methods) { //check if methods exist.
                    const methodKeys = Object.keys(methods);
                    methodKeys.sort((a, b) => a.localeCompare(b));

                    methodKeys.forEach(methodKey => {

                        // const childCall = methods[methodKey] ? methods[methodKey].meta : { description: "" };  //handle if meta is missing
                        const childCall = { description: "Desc", type: "Type" };  //handle if meta is missing

                        const callDescription = FormatDescription('', childCall.description);
                        let listItems;
                        switch (type) {
                            case "rpc":
                                listItems = (
                                    React.createElement('ul', { style: NoMargin },
                                        React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Description"), ": ", callDescription),
                                        React.createElement('li', { className: "searchable" }, React.createElement('u', null, "API Endpoint"), ": ", React.createElement('span', { style: PinkText }, `api.rpc.${key}.${methodKey}`)),
                                        React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Return Type"), ": ", childCall.type),
                                        React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Parameters"), ": ", FormatArgs(childCall, "rpc"))
                                    )
                                );
                                break;
                            case "runtime":
                                listItems = (
                                    React.createElement('ul', { style: NoMargin },
                                        React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Description"), ": ", callDescription),
                                        React.createElement('li', { className: "searchable" }, React.createElement('u', null, "API Endpoint"), ": ", React.createElement('span', { style: PinkText }, `api.call.${key}.${methodKey}`)),
                                        React.createElement('li', { className: "searchable" }, React.createElement('u', null, "Type"), ": ", childCall.type)
                                    )
                                );
                                break;
                            default:
                                break;
                        }
                        const item = (
                            React.createElement('div', { key: `${key}.${methodKey}` },
                                React.createElement('b', null, `${methodKey.charAt(0).toUpperCase() + methodKey.slice(1)}`),
                                listItems
                            )
                        );
                        children.push(item);
                    });
                }
                children = IsEmpty(children);
                const header = key.charAt(0).toUpperCase() + key.slice(1);
                const formattedCalls = (
                    React.createElement('div', { key: key, style: SecondLevel },
                        React.createElement('span', null,
                            React.createElement('b', { id: `${key}-button`, style: TreeControl, onClick: () => { ToggleExpand(key) } }, "+"),
                            " ",
                            React.createElement('b', null, header)
                        ),
                        React.createElement('div', { id: key, style: TopLevelDiv },
                            React.createElement('ul', { style: NoMargin },
                                children
                            )
                        )
                    )
                );
                output.push(formattedCalls);
                Expandable.push(key);
            });
            return output;
        }

        function Camel(input) {
            return input.charAt(0).toLowerCase() + input.slice(1);
        }

        function IsEmpty(result) {
            if (result.length === 0) { return (React.createElement('p', { style: NoMargin }, "None")) }
            else { return result; }
        }

        function CompilePalletSection(palletName, category, items) {
            return (
                React.createElement('ul', { style: NoMargin },
                    React.createElement('span', null,
                        React.createElement('b', { id: `${palletName}-${category}-button`, style: TreeControl, onClick: () => { ToggleExpand(`${palletName}-${category}`) } }, "+"),
                        " ",
                        React.createElement('b', null, category.charAt(0).toUpperCase() + category.slice(1))
                    ),
                    React.createElement('div', { id: `${palletName}-${category}`, style: CollapsedDiv },
                        React.createElement('ul', null, items)
                    )
                )
            )
        }


        function BuildDocLink(pallet, method) {
            let mapped = PalletNameMappings[pallet] != undefined ? PalletNameMappings[pallet] : pallet;
            if (CommonRuntimeModules.includes(pallet)) {
                return `https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_common/${mapped}/pallet/struct.Pallet.html#method.${method}`;
            } else if (CommonParachainRuntimeModules.includes(mapped)) {
                return `https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/${mapped}/pallet/struct.Pallet.html#method.${method}`;
            } else if (pallet == "staking") {
                // not sure why this needs a special link, but oh well
                return `https://paritytech.github.io/polkadot-sdk/master/pallet_${mapped}/struct.Pallet.html#method.${method}`;
            }
            else if (mapped.startsWith("frame_")) {
                return `https://paritytech.github.io/polkadot-sdk/master/${mapped}/pallet/struct.Pallet.html#method.${method}`;

            } else {
                return `https://paritytech.github.io/polkadot-sdk/master/pallet_${mapped}/pallet/struct.Pallet.html#method.${method}`;
            }
        }


        function FormatDescription(pallet, description) {
            let descriptionItems = description.split("`");
            let output = [];
            for (let i = 0; i < descriptionItems.length; i++) {
                if (i % 2 === 0) {
                    output.push(React.createElement('p', { key: i, style: DescriptionRegular }, descriptionItems[i]))
                } else if (descriptionItems[i].startsWith("Pallet::")) {
                    let method = descriptionItems[i].split("Pallet::")[1];
                    let link = BuildDocLink(pallet, method);
                    output.push(React.createElement('a', { key: i, target: "_blank", href: link, style: DescriptionHighlighting }, descriptionItems[i]))
                }

                else {
                    output.push(React.createElement('p', { key: i, style: DescriptionHighlighting }, descriptionItems[i]))
                }
            }
            return React.createElement('span', null, output);
        }

        function FormatArgs(item, type, types = null) {
            let params = "(";
            switch (type) {
                case "rpc":
                    if (item.params) { //check params exist
                        item.params.forEach(param => {
                            params += `${param.name}: ${param.type}, `;
                        });
                    }
                    break;
                case "extrinsics":
                    if (item.args) { //check args exist
                        for (let i = 0; i < item.args.length; i++) {
                            params += `${item.args[i].name}: ${item.args[i].type}, `
                        }
                    }
                    break;
                case "events":
                    if (item.args) { //check args exist
                        for (let i = 0; i < item.args.length; i++) {
                            params += `${item.fields && item.fields[i] ? item.fields[i].typeName : 'unknown'}: ${item.args[i]}, ` //check fields and typeName exist
                        }
                    }
                    break;
                case "storage":
                    if (item.type) { //check type exists
                        const key = Object.keys(item.type)[0];
                        if (key === "Plain") {
                            const typeKey = item.type.Plain;
                            const def = types && types[typeKey] ? types[typeKey].type.def : {}; //safely check for types
                            params = StorageDecoder(def, types);
                        } else if (key === "Map") {
                            const typeKey = item.type.Map.key;
                            const def = types && types[typeKey] ? types[typeKey].type.def : {}; //safely check for types
                            params = StorageDecoder(def, types);
                        } else {
                            console.log("Unknown Storage Type");
                        }
                    }
                    break;
                default:
                    break;
            }
            params = `${params.slice(0, -2)})`;
            if (params === "(" || params === ")") { params = "None"; }
            return params;
        }

        function StorageDecoder(def, types) {
            let params = "(";
            const type = Object.keys(def)[0];

            if (!types) {
                return "(Type information unavailable)"; // Early exit if types are missing.
            }


            switch (type) {
                case "Array":
                    const length = def.Array.len;
                    const arrayTypeDef = types[def.Array.type]?.type.def || {}; //safely check for types
                    const typeDefKey = Object.keys(arrayTypeDef)[0];
                    const typeDefValue = arrayTypeDef[typeDefKey];
                    params += `Array[${length}]: ${typeDefKey} ${typeDefValue} )`;
                    break;

                case "Compact":
                    params = StorageDecoder(types[def.Compact.type]?.type.def || {}, types); //safely get def
                    break;

                case "Composite":
                    if (def.Composite && def.Composite.fields) { // Check for valid Composite
                        def.Composite.fields.forEach((item) => {
                            params = StorageDecoder(types[item.type]?.type.def || {}, types); //safely get def
                        });
                    }
                    break;
                case "Primitive":
                    const primitiveType = def.Primitive;
                    params += `Primitive: ${primitiveType}) `;
                    break;
                case "Sequence":
                    params = StorageDecoder(types[def.Sequence.type]?.type.def || {}, types); //safely get def

                    break;
                case "Tuple":
                    params += "Tuple: [ "
                    if (def.Tuple) { // Check for valid Tuple
                        def.Tuple.forEach((item) => {
                            params += `${StorageDecoder(types[item]?.type.def || {}, types)}, `; //safely get def
                        });
                    }
                    params = `${params.slice(0, -2)}] `;
                    break;
                case "Variant":
                    params += "Variant: "
                    if (def.Variant && def.Variant.variants) {
                        def.Variant.variants.forEach((variant) => {
                            let fieldNames = [];
                            if (variant.fields) {
                                variant.fields.forEach((field) => {
                                    fieldNames.push(field.typeName);
                                });
                            }
                            params += `{${variant.name}: [${fieldNames.join(", ")}]}, `
                        });
                    }
                    params = `${params.slice(0, -2)} `;
                    break;
                default:
                    console.log("Unknown Decoder Type");
                    break;
            }
            return params;
        }


        function ToggleLoading(id, hidden) {
            const el = document.getElementById(id);
            if (el !== null) {
                if (hidden === false) { el.style.display = "block"; }
                else { el.style.display = "none" };
            }
        }

        function ToggleExpand(id) {
            const div = document.getElementById(id);
            const button = document.getElementById(`${id}-button`);
            if (div && button) { // Check for existence
                if (div.style.maxHeight === "0px") {
                    div.style.maxHeight = "100%";
                    button.innerText = "-";
                } else {
                    div.style.maxHeight = "0px";
                    button.innerText = "+";
                }
            }
        }

        function ExpandAll(bool) {
            Expandable.forEach(item => {
                const div = document.getElementById(item);
                const button = document.getElementById(`${item}-button`);
                if (div && button) { // Check for existence
                    if (bool) {
                        div.style.maxHeight = "100%";
                        button.innerText = "-";
                    } else {
                        div.style.maxHeight = "0px";
                        button.innerText = "+";
                    }
                }
            })
        }

        function Search() {
            ToggleLoading("searchLoading", false);
            clearTimeout(SearchThrottle);
            SearchThrottle = setTimeout(function () {
                const query = document.getElementById("metaSearch").value;
                if (query.length < 2) {
                    ExpandAll(false);
                    Expandable.forEach((elementId) => {
                        const div = document.getElementById(elementId);
                        const searchable = div ? div.getElementsByClassName("searchable") : []; // Check for existence
                        for (let item of searchable) { item.style.background = "transparent"; }
                    })
                    ToggleLoading("searchResults", true);
                } else {
                    const matcher = new RegExp(query, "gi");
                    let matchCount = 0;
                    Expandable.forEach((elementId) => {
                        const div = document.getElementById(elementId);
                        const searchable = div ? div.getElementsByClassName("searchable") : []; //check for existence
                        const button = document.getElementById(`${elementId}-button`);

                        if (div && matcher.test(div.innerText)) { //check for null
                            for (let item of searchable) {
                                if (matcher.test(item.innerText)) {
                                    item.style.background = "#ffff00";
                                    matchCount += 1;
                                } else { item.style.background = "transparent"; }
                            }
                            div.style.maxHeight = "100%";
                            if (button) button.innerText = "-"; // Check for null
                        } else {
                            for (let item of searchable) { item.style.background = "transparent"; }
                            if (div) div.style.maxHeight = "0px";  // Check for null
                            if (button) button.innerText = "+";     // Check for null
                        }
                        if (document.getElementById("searchCount")) {  //check exists
                            document.getElementById("searchCount").innerText = matchCount;
                        }
                    });
                    ToggleLoading("searchResults", false);
                }
                ToggleLoading("searchLoading", true);
            }, 200); // Perform search after 0.2s
        }

        const PinkText = { color: "#e6007a" };
        const ExplorerControls = { textAlign: "center " };
        const DescriptionRegular = { margin: "0px", display: "inline" };
        const DescriptionHighlighting = { color: "#e6007a", margin: "0px", display: "inline", background: "#f0f0f0", paddingLeft: "5px", paddingRight: "5px" }
        const TopLevelDiv = { maxHeight: "0px", overflow: "hidden" };
        const CollapsedDiv = { maxHeight: "0px", overflow: "hidden", margin: "0px" };
        const NoMargin = { margin: "0px" };
        const DropDownStyle = { border: "1px solid #e6007a", width: "400px", height: "40px", fontSize: "16px", textAlign: "center", fontWeight: "bold", margin: "1px", cursor: "pointer" };
        const ExpandCollapseButton = { border: "1px solid #e6007a", width: "199px", height: "28px", margin: "1px", fontWeight: "bold", cursor: "pointer" };
        const LoadingStatus = { display: "none" };
        const TreeControl = { margin: "0px", color: "#e6007a", cursor: "pointer" };
        const SearchStyle = { border: "1px solid #e6007a", width: "400px", height: "40px", fontSize: "16px", textAlign: "center", margin: "1px" }
        const TopLevel = { fontSize: "18px" }
        const SecondLevel = { paddingLeft: "16px" }



        // Render the component
        ReactDOM.render(
            React.createElement(Metadata, { version: "V14" }), // Use the correct metadata version
            document.getElementById('root')
        );
    </script>
</body>

</html>

{% endblock %}